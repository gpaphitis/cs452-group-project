package main

import (
	"cs452/internal/mapreduce"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strconv"
	"strings"
)

// The mapping function is called once for each piece of the input.
// In this framework, the key is the name of the file that is being processed,
// and the value is the file's contents. The return value should be a slice of
// key/value pairs, each represented by a mapreduce.KeyValue.
func mapF(document, value string) (res []mapreduce.KeyValue) {
	// Split on non-alphanumeric characters using regexp
	re := regexp.MustCompile(`[^a-zA-Z]+`)
	words := re.Split(value, -1)

	seen := make(map[string]bool)
	base := filepath.Base(document)
	for _, w := range words {
		if w == "" {
			continue
		}
		if seen[w] {
			continue
		}
		seen[w] = true
		res = append(res, mapreduce.KeyValue{Key: w, Value: base})
	}
	return res
}

// The reduce function is called once for each key generated by Map, with a
// list of that key's string value (merged across all inputs). The return value
// should be a single output value for that key.
func reduceF(key string, values []string) string {
	sort.Strings(values)
	size := len(values)
	documents := strings.Join(values, ",")
	return strconv.Itoa(size) + " " + documents
}

// Can be run in 3 ways:
// 1) Sequential (e.g., go run wc.go master sequential x1.txt .. xN.txt)
// 2) Master (e.g., go run wc.go master localhost:7777 x1.txt .. xN.txt)
// 3) Worker (e.g., go run wc.go worker localhost:7777 localhost:7778 &)

func runApplicationMode(args []string) {
	appAddr := ":9000"
	masterAddr := ":9100"

	if len(args) >= 1 {
		appAddr = args[0]
	}
	if len(args) >= 2 {
		masterAddr = args[1]
	}

	app := mapreduce.NewApplication(appAddr, masterAddr)

	if err := app.Listen(); err != nil {
		log.Fatalf("failed to start Application RPC server: %v", err)
	}

	fmt.Printf("Application listening for RunTask RPCs on %s\n", appAddr)
	fmt.Printf("Master listening for Worker RPCs on %s\n", masterAddr)
	fmt.Println("Waiting for RunTask calls...")

	select {} // block forever
}

func runWorkerMode(args []string) {
	if len(args) < 2 {
		fmt.Println("Usage: go run main.go worker [masterAddr] [workerAddr]")
		os.Exit(1)
	}
	masterAddr := args[0]
	workerAddr := args[1]

	fmt.Printf("Starting worker at %s, registering with master %s...\n", workerAddr, masterAddr)

	// Create and start the worker.
	mapreduce.RunWorker(masterAddr, workerAddr, 100)
}

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage:")
		fmt.Println("  go run main.go application [appAddr] [masterAddr]")
		fmt.Println("  go run main.go worker [masterAddr] [workerAddr]")
		os.Exit(1)
	}

	mode := os.Args[1]

	switch mode {
	case "application":
		runApplicationMode(os.Args[2:])

	case "worker":
		runWorkerMode(os.Args[2:])

	default:
		fmt.Printf("Unknown mode: %s\n", mode)
		os.Exit(1)
	}
}
